---
title: "백준 10058번 센서 네트워크"

category: "boj solution"
tags: ["boj", "geometry", "bipartite_matching"]
math: true
--- 

[문제 링크](https://acmicpc.net/problem/10058)

정답인 집합 $s$를 생각하자.
$s$에서 가장 먼 두 점을 $a, b$와 그 거리를 $d$라고 하자.

$a, b$를 중심으로 하고 반지름이 $d$인 두 원을 생각하자.

![img1](/assets/img/posts/boj-10058-1.jpg)


$a, b$가 가장 먼 두 점이기 때문에 두 원이 겹치는 영역안에 집합의 모든 점이 들어갈 수 있다.
선분 $\overline{ab}$을 기준으로 두 구역 $p, q$로 나누자. 같은 구역에 있는 점은 거리가 $d$이하이다.


![img2](/assets/img/posts/boj-10058-2.jpg)


만약 집합이 올바른 정답이려면 $p$의 한 점과 $q$의 한 점의 거리는 $d$이하이다.


![img3](/assets/img/posts/boj-10058-3.jpg)


그러면 원래 문제로 돌아오자.


임의의 두 점 $a, b$를 고정하자. $a, b$ 사이 거리를 $d$라고 하고 $a, b$와의 거리가 $d$이하인 점만 보자. 점을 $\overline{ab}$ 기준으로 두 구역 $p, q$로 나누자.


$p$의 한 점과 $q$의 한 점 사이 거리가 $d$이상이라면 두 점에 간선을 잇자. 그렇게 나온 그래프는 이분그래프이다. 정점을 적당히 지워서 모든 간선을 지울 수 있다면 $a, b$를 가장 먼 점으로 가지는 정답 후보를 찾을 수 있다. 문제가 minimum vertex cover문제로 환원되었다. 지울 정점은 이분매칭을 통해 구할 수 있다.


```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const int MAXC = 600000;

ll N, tree[4*MAXC];

void update(int x, ll v, int s = 0, int e = MAXC, int idx = 1)
{
    if(e < x || x < s) return;
    if(s == e) {
        tree[idx] = min(tree[idx], v);
        return;
    }
    int m = (s + e) / 2;
    update(x, v, s, m, 2*idx);
    update(x, v, m+1, e, 2*idx+1);
    tree[idx] = min(tree[2*idx], tree[2*idx+1]);
}

ll query(int l, int r, int s = 0, int e = MAXC, int idx = 1)
{
    if(e < l || r < s) return 1e18;
    if(l <= s && e <= r) return tree[idx];
    int m = (s + e) / 2;
    return min(query(l, r, s, m, 2*idx), query(l, r, m+1, e, 2*idx+1));
}

void dfs(int idx, ll a, ll b, ll c, vector<ll>& A, vector<pair<ll, ll>>& out)
{
    if(idx == A.size()) {
        out.emplace_back(c - b, b - a);
        return;
    }

    dfs(idx + 1, a + A[idx], b, c, A, out);
    dfs(idx + 1, a, b + A[idx], c, A, out);
    dfs(idx + 1, a, b, c + A[idx], A, out);
}

int main()
{
    cin >> N;
    vector<ll> A(N);
    for(int i = 0; i < N; i++) cin >> A[i];
    int m = N / 2;
    vector<ll> front(A.begin(), A.begin() + m), back(A.begin() + m, A.end());
    vector<pair<ll, ll>> front_out, back_out;
    dfs(0, 0, 0, 0, front, front_out);
    dfs(0, 0, 0, 0, back, back_out);
    sort(front_out.begin(), front_out.end());
    sort(back_out.begin(), back_out.end());

    vector<ll> v;
    v.reserve(back_out.size());
    for(auto [a, b] : back_out) v.push_back(b);
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());

    fill(tree, tree + 4*MAXC, 1e18);

    ll ans = 1e18;
    int j = back_out.size() - 1;
    for(int i = 0; i < front_out.size(); i++) {
        while(j >= 0 && front_out[i].first + back_out[j].first >= 0) {
            int idx = lower_bound(v.begin(), v.end(), back_out[j].second) - v.begin();
            update(idx, back_out[j].first + back_out[j].second);
            j--;
        }
        int idx = lower_bound(v.begin(), v.end(), -front_out[i].second) - v.begin();
        ans = min(ans, front_out[i].first + front_out[i].second + query(idx, MAXC));
    }
    cout << ans;
}
```